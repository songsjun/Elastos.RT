//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

library
{
    enum MarshalType {
        MarshalType_IPC,
        MarshalType_RPC,
    }

    enum UnmarshalFlag {
        UnmarshalFlag_Noncoexisting     = 0x10,
        UnmarshalFlag_Coexisting        = 0x20,
    }


    [deprecated]
    interface IParcel {
        AppendFrom(
            [in] IParcel* parcel,
            [in] Int32 offset,
            [in] Int32 length);

        HasFileDescriptors(
            [out] Boolean* result);

        ReadByte(
            [out] Byte *value);

        WriteByte(
            [in] Byte value);

        ReadBoolean(
            [out] Boolean *value);

        WriteBoolean(
            [in] Boolean value);

        ReadChar8(
            [out] Char32 *value);

        WriteChar8(
            [in] Char32 value);

        ReadChar16(
            [out] Char16 *value);

        WriteChar16(
            [in] Char16 value);

        ReadInt16(
            [out] Int16 *value);

        WriteInt16(
            [in] Int16 value);

        ReadInt32(
            [out] Int32 *value);

        WriteInt32(
            [in] Int32 value);

        ReadInt64(
            [out] Int64 *value);

        WriteInt64(
            [in] Int64 value);

        ReadFloat(
            [out] Float *value);

        WriteFloat(
            [in] Float value);

        ReadDouble(
            [out] Double *value);

        WriteDouble(
            [in] Double value);

        ReadCString(
            [out] String* str);

        WriteCString(
            [in] String str);

        ReadString(
            [out] String* str);

        WriteString(
            [in] String str);

        ReadStruct(
            [out] Handle32 *address);

        WriteStruct(
            [in] Handle32 value,
            [in] Int32 size);

        ReadEMuid(
            [out] EMuid *id);

        WriteEMuid(
            [in] EMuid id);

        ReadEGuid(
            [out] EGuid *id);

        WriteEGuid(
            [in] EGuid id);

        ReadArrayOf(
            [out] Handle32 *array);

        WriteArrayOf(
            [in] Handle32 array);

        ReadArrayOfCString(
            [out, callee] ArrayOf<String>* array);

        WriteArrayOfCString(
            [in] ArrayOf<String>* array);

        ReadArrayOfString(
            [out, callee] ArrayOf<String>* array);

        WriteArrayOfString(
            [in] ArrayOf<String>* array);

        ReadBufferOf(
            [out] Handle32 *buffer);

        WriteBufferOf(
            [in] Handle32 buffer);

        ReadBufferOfCString(
            [out] Handle32 *buffer);

        WriteBufferOfCString(
            [in] BufferOf<String> buffer);

        ReadBufferOfString(
            [out] Handle32 *buffer);

        WriteBufferOfString(
            [in] BufferOf<String> buffer);

        ReadStringBuf(
            [out] Handle32 *buffer);

        WriteStringBuf(
            [in] Handle32 buffer);

        ReadMemoryBuf(
            [out] Handle32 *buffer);

        WriteMemoryBuf(
            [in] Handle32 buffer);

        ReadInterfacePtr(
            [out] Handle32 *itfpp);

        WriteInterfacePtr(
            [in] IInterface* value);

        ReadBytePtr(
            [out] Handle32 *bypp);

        WriteBytePtr(
            [in] Handle32 address);

        ReadBooleanPtr(
            [out] Handle32 *bopp);

        WriteBooleanPtr(
            [in] Handle32 address);

        ReadChar8Ptr(
            [out] Handle32 *c8pp);

        WriteChar8Ptr(
            [in] Handle32 address);

        ReadChar16Ptr(
            [out] Handle32 *c16pp);

        WriteChar16Ptr(
            [in] Handle32 address);

        ReadInt16Ptr(
            [out] Handle32 *i16pp);

        WriteInt16Ptr(
            [in] Handle32 address);

        ReadInt32Ptr(
            [out] Handle32 *i32pp);

        WriteInt32Ptr(
            [in] Handle32 address);

        ReadInt64Ptr(
            [out] Handle32 *i64pp);

        WriteInt64Ptr(
            [in] Handle32 address);

        ReadFloatPtr(
            [out] Handle32 *fpp);

        WriteFloatPtr(
            [in] Handle32 address);

        ReadDoublePtr(
            [out] Handle32 *dpp);

        WriteDoublePtr(
            [in] Handle32 address);

        ReadCStringPtr(
            [out] Handle32 *address);

        ReadStringPtr(
            [out] Handle32 *address);

        WriteStringPtr(
            [in] Handle32 address);

        ReadStructPtr(
            [out] Handle32 *address);

        ReadEMuidPtr(
            [out] Handle32 *idpp);

        WriteEMuidPtr(
            [in] Handle32 idPtr);

        ReadEGuidPtr(
            [out] Handle32 *idpp);

        WriteEGuidPtr(
            [in] Handle32 idPtr);

        ReadInterfacePtrPtr(
            [out] Handle32 *itfpp);

        WriteInterfacePtrPtr(
            [in] Handle32 address);

        ReadBufferOfPtr(
            [out] Handle32 *buffer);

        // Place a file descriptor into the parcel.  The given fd must remain
        // valid for the lifetime of the parcel.
        WriteFileDescriptor(
            [in] Int32 fd);

        // Place a file descriptor into the parcel.  A dup of the fd is made, which
        // will be closed once the parcel is destroyed.
        WriteDupFileDescriptor(
            [in] Int32 fd);

        // Retrieve a file descriptor from the parcel.  This returns the raw fd
        // in the parcel, which you do not own -- use dup() to get your own copy.
        ReadFileDescriptor(
            [out] Int32* fd);

        Clone(
            [in] IParcel* srcParcel);

        GetDataPosition(
            [out] Int32* position);

        SetDataPosition(
            [in] Int32 position);

        GetElementPayload(
            [out] Handle32* buffer);

        GetElementSize(
            [out] Int32* size);
    }

    interface IParcelable {
        /**
         * Flag for use with {@link #writeToParcel}: the object being written
         * is a return value, that is the result of a function such as
         * "<code>Parcelable someFunction()</code>",
         * "<code>void someFunction(out Parcelable)</code>", or
         * "<code>void someFunction(inout Parcelable)</code>".  Some implementations
         * may want to release resources at this point.
         */
        const Int32 PARCELABLE_WRITE_RETURN_VALUE = 0x0001;

        /**
         * Bit masks for use with {@link #describeContents}: each bit represents a
         * kind of object considered to have potential special significance when
         * marshalled.
         */
        const Int32 CONTENTS_FILE_DESCRIPTOR = 0x0001;

        ReadFromParcel(
            [in] IParcel* source);

        WriteToParcel(
            [in] IParcel* dest);
    }

    interface ICustomMarshal {
        GetClsid(
            [out] ClassID* clsid);

        CreateObject(
            [in] ICustomMarshal* originProxy,
            [out] IInterface** newProxy);
    }
}
