//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    merge("../../../car/elastos/utility/Exceptions.car");
    merge("../../../car/elastos/utility/IObjectEnumerator.car");
    merge("../../../car/elastos/utility/IObjectContainer.car");
    merge("../../../car/elastos/utility/IBitSet.car");
    merge("../../../car/elastos/utility/IDate.car");
    merge("../../../car/elastos/utility/ICalendar.car");
    merge("../../../car/elastos/utility/IIterable.car");
    merge("../../../car/elastos/utility/ICollection.car");
    merge("../../../car/elastos/utility/IList.car");
    merge("../../../car/elastos/utility/ILocale.car");
    merge("../../../car/elastos/utility/IMap.car");
    merge("../../../car/elastos/utility/ILinkedList.car");
    merge("../../../car/elastos/utility/IDictionary.car");
    merge("../../../car/elastos/utility/IProperties.car");
    merge("../../../car/elastos/utility/IEnumeration.car");
    merge("../../../car/elastos/utility/IGregorianCalendar.car");
    merge("../../../car/elastos/utility/IIterator.car");
    merge("../../../car/elastos/utility/IListIterator.car");
    merge("../../../car/elastos/utility/IObjectStringMap.car");
    merge("../../../car/elastos/utility/IObjectInt32Map.car");
    merge("../../../car/elastos/utility/IObjectMap.car");
    merge("../../../car/elastos/utility/IQueue.car");
    merge("../../../car/elastos/utility/IDeque.car");
    merge("../../../car/elastos/utility/IRandomAccess.car");
    merge("../../../car/elastos/utility/ITimeZone.car");
    merge("../../../car/elastos/utility/IZoneInfo.car");
    merge("../../../car/elastos/utility/ISimpleTimeZone.car");
    merge("../../../car/elastos/utility/ITimerTask.car");
    merge("../../../car/elastos/utility/ITimer.car");
    merge("../../../car/elastos/utility/ICurrency.car");
    merge("../../../car/elastos/utility/IUUID.car");
    merge("../../../car/elastos/utility/IZoneInfoDB.car");
    merge("../../../car/elastos/utility/ITimeZoneGetter.car");
    merge("../../../car/elastos/utility/IArrayList.car");
    merge("../../../car/elastos/utility/IFormattableFlags.car");
    merge("../../../car/elastos/utility/IFormatter.car");
    merge("../../../car/elastos/utility/IFormattable.car");
    merge("../../../car/elastos/utility/IArrayDeque.car");
    merge("../../../car/elastos/utility/IComparableTimSort.car");
    merge("../../../car/elastos/utility/IDualPivotQuicksort.car");
    merge("../../../car/elastos/utility/IEventListener.car");
    merge("../../../car/elastos/utility/IEventListenerProxy.car");
    merge("../../../car/elastos/utility/IEventObject.car");
    merge("../../../car/elastos/utility/IResourceBundle.car");
    merge("../../../car/elastos/utility/IListResourceBundle.car");
    merge("../../../car/elastos/utility/ISortedMap.car");
    merge("../../../car/elastos/utility/INavigableMap.car");
    merge("../../../car/elastos/utility/ISet.car");
    merge("../../../car/elastos/utility/ISortedSet.car");
    merge("../../../car/elastos/utility/INavigableSet.car");
    merge("../../../car/elastos/utility/IObserver.car");
    merge("../../../car/elastos/utility/IObservable.car");
    merge("../../../car/elastos/utility/IPriorityQueue.car");
    merge("../../../car/elastos/utility/IPropertyResourceBundle.car");
    merge("../../../car/elastos/utility/IScanner.car");
    merge("../../../car/elastos/utility/IServiceLoader.car");
    merge("../../../car/elastos/utility/IVector.car");
    merge("../../../car/elastos/utility/IArrays.car");
    merge("../../../car/elastos/utility/IStack.car");
    merge("../../../car/elastos/utility/IStringTokenizer.car");
    merge("../../../car/elastos/utility/IUnsafeArrayList.car");
    merge("../../../car/elastos/utility/ICollections.car");
    merge("../../../car/elastos/utility/IEnumMap.car");

    merge("../../../car/elastos/utility/regex/IMatchResult.car");
    merge("../../../car/elastos/utility/regex/IMatcher.car");
    merge("../../../car/elastos/utility/regex/ISplitter.car");
    merge("../../../car/elastos/utility/regex/IPattern.car");

    merge("../../../car/elastos/utility/logging/ILevel.car");
    merge("../../../car/elastos/utility/logging/IErrorManager.car");
    merge("../../../car/elastos/utility/logging/IFilter.car");
    merge("../../../car/elastos/utility/logging/ILogFormatter.car");
    merge("../../../car/elastos/utility/logging/ILogHandler.car");
    merge("../../../car/elastos/utility/logging/ILogger.car");
    merge("../../../car/elastos/utility/logging/ILoggingMXBean.car");
    merge("../../../car/elastos/utility/logging/ILogManager.car");
    merge("../../../car/elastos/utility/logging/ILogRecord.car");
    merge("../../../car/elastos/utility/logging/IStreamHandler.car");
    merge("../../../car/elastos/utility/logging/IConsoleHandler.car");
    merge("../../../car/elastos/utility/logging/IMemoryHandler.car");
    merge("../../../car/elastos/utility/logging/ISimpleFormatter.car");
    merge("../../../car/elastos/utility/logging/ISocketHandler.car");
    merge("../../../car/elastos/utility/logging/IXMLFormatter.car");

    merge("../../../car/elastos/utility/prefs/INodeChangeEvent.car");
    merge("../../../car/elastos/utility/prefs/INodeChangeListener.car");
    merge("../../../car/elastos/utility/prefs/IPreferenceChangeEvent.car");
    merge("../../../car/elastos/utility/prefs/IPreferenceChangeListener.car");
    merge("../../../car/elastos/utility/prefs/IPreferences.car");
    merge("../../../car/elastos/utility/prefs/IPreferencesFactory.car");
    merge("../../../car/elastos/utility/prefs/IXMLParser.car");
    merge("../../../car/elastos/utility/prefs/IAbstractPreferences.car");
    merge("../../../car/elastos/utility/prefs/IFilePreferencesFactoryImpl.car");
    merge("../../../car/elastos/utility/prefs/IFilePreferencesImpl.car");

    merge("../../../car/elastos/utility/spi/ILocaleServiceProvider.car");
    merge("../../../car/elastos/utility/spi/ICurrencyNameProvider.car");
    merge("../../../car/elastos/utility/spi/ILocaleNameProvider.car");
    merge("../../../car/elastos/utility/spi/ITimeZoneNameProvider.car");

    interface Libcore.ICU.ILocale;
    interface Elastos.Core.ICloneable;
    interface Elastos.Core.IAppendable;
    interface Elastos.Core.IComparator;
    interface Elastos.Core.IComparable;
    interface Elastos.IO.ISerializable;
    interface Elastos.IO.IFile;
    interface Elastos.IO.IInputStream;
    interface Elastos.IO.IOutputStream;
    interface Elastos.IO.IPrintStream;
    interface Elastos.IO.IFlushable;
    interface Elastos.IO.ICloseable;
    interface Elastos.IO.IReadable;
    interface Elastos.IO.IReader;
    interface Elastos.IO.Channels.IReadableByteChannel;

    namespace Elastos {
    namespace Utility {

    // [deprecated]
    // class CBitSet {
    //     /**
    //      * Creates a new {@code BitSet} with size equal to 64 bits.
    //      */
    //     constructor();

    //     /**
    //      * Creates a new {@code BitSet} with size equal to {@code bitCount}, rounded up to
    //      * a multiple of 64.
    //      *
    //      * @throws NegativeArraySizeException if {@code bitCount < 0}.
    //      */
    //     constructor(
    //         [in] Int32 bitCount);

    //     /* private */
    //     constructor(
    //         [in] ArrayOf<Int64>* bits);

    //     interface IBitSet;
    //     interface ISerializable;
    //     interface ICloneable;
    // }

    // singleton class CBitSetHelper {
    //     interface IBitSetHelper;
    // }

    // class CObjectStringMap {
    //     interface IObjectStringMap;
    // }

    // class CObjectInt32Map {
    //     interface IObjectInt32Map;
    // }

    // class CObjectMap {
    //     interface IObjectMap;
    // }

    // singleton class CZoneInfoDB {
    //     constructor();

    //     interface IZoneInfoDB;
    // }

    // class CUUID {
    //     /**
    //      * <p>
    //      * Constructs an instance with the specified bits.
    //      *
    //      * @param mostSigBits
    //      *            The 64 most significant bits of the UUID.
    //      * @param leastSigBits
    //      *            The 64 least significant bits of the UUID.
    //      */
    //     constructor(
    //         [in] Int64 mostSigBits,
    //         [in] Int64 leastSigBits);

    //     interface IUUID;
    //     interface ISerializable;
    // }

    // singleton class CUUIDHelper {
    //     interface IUUIDHelper;
    // }

    // /**
    //  * {@code Date} represents a specific moment in time, to the millisecond.
    //  *
    //  * @see System#currentTimeMillis
    //  * @see Calendar
    //  * @see GregorianCalendar
    //  * @see SimpleTimeZone
    //  * @see TimeZone
    //  */
    // class CDate {
    //     /**
    //      * Initializes this {@code Date} instance to the current time.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new {@code Date} initialized to midnight in the default {@code TimeZone} on
    //      * the specified date.
    //      *
    //      * @param year
    //      *            the year, 0 is 1900.
    //      * @param month
    //      *            the month, 0 - 11.
    //      * @param day
    //      *            the day of the month, 1 - 31.
    //      *
    //      * @deprecated use
    //      *             {@link GregorianCalendar#GregorianCalendar(int, int, int)}
    //      */
    //     //@Deprecated
    //     constructor(
    //         [in] Int32 year,
    //         [in] Int32 month,
    //         [in] Int32 day);

    //     /**
    //      * Constructs a new {@code Date} initialized to the specified date and time in the
    //      * default {@code TimeZone}.
    //      *
    //      * @param year
    //      *            the year, 0 is 1900.
    //      * @param month
    //      *            the month, 0 - 11.
    //      * @param day
    //      *            the day of the month, 1 - 31.
    //      * @param hour
    //      *            the hour of day, 0 - 23.
    //      * @param minute
    //      *            the minute of the hour, 0 - 59.
    //      *
    //      * @deprecated use
    //      *             {@link GregorianCalendar#GregorianCalendar(int, int, int, int, int)}
    //      */
    //     //@Deprecated
    //     constructor(
    //         [in] Int32 year,
    //         [in] Int32 month,
    //         [in] Int32 day,
    //         [in] Int32 hour,
    //         [in] Int32 minute);

    //         /**
    //      * Constructs a new {@code Date} initialized to the specified date and time in the
    //      * default {@code TimeZone}.
    //      *
    //      * @param year
    //      *            the year, 0 is 1900.
    //      * @param month
    //      *            the month, 0 - 11.
    //      * @param day
    //      *            the day of the month, 1 - 31.
    //      * @param hour
    //      *            the hour of day, 0 - 23.
    //      * @param minute
    //      *            the minute of the hour, 0 - 59.
    //      * @param second
    //      *            the second of the minute, 0 - 59.
    //      *
    //      * @deprecated use
    //      *             {@link GregorianCalendar#GregorianCalendar(int, int, int, int, int, int)}
    //      */
    //     //@Deprecated
    //     constructor(
    //         [in] Int32 year,
    //         [in] Int32 month,
    //         [in] Int32 day,
    //         [in] Int32 hour,
    //         [in] Int32 minute,
    //         [in] Int32 second);

    //     /**
    //      * Initializes this {@code Date} instance using the specified millisecond value. The
    //      * value is the number of milliseconds since Jan. 1, 1970 GMT.
    //      *
    //      * @param milliseconds
    //      *            the number of milliseconds since Jan. 1, 1970 GMT.
    //      */
    //     constructor(
    //         [in] Int64 milliseconds);

    //     /**
    //      * Constructs a new {@code Date} initialized to the date and time parsed from the
    //      * specified String.
    //      *
    //      * @param string
    //      *            the String to parse.
    //      *
    //      * @deprecated use {@link DateFormat}
    //      */
    //     //@Deprecated
    //     constructor(
    //         [in] String string);

    //     interface IDate;
    //     interface ISerializable;
    //     interface ICloneable;
    //     interface IComparable;
    // }

    // singleton class CDateHelper {
    //     interface IDateHelper;
    // }

    // class CGregorianCalendar {
    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to the current date and
    //      * time with the default {@code Locale} and {@code TimeZone}.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to midnight in the default
    //      * {@code TimeZone} and {@code Locale} on the specified date.
    //      *
    //      * @param year
    //      *            the year.
    //      * @param month
    //      *            the month.
    //      * @param day
    //      *            the day of the month.
    //      */
    //     constructor(
    //         [in] Int32 year,
    //         [in] Int32 month,
    //         [in] Int32 day);

    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to the specified date and
    //      * time in the default {@code TimeZone} and {@code Locale}.
    //      *
    //      * @param year
    //      *            the year.
    //      * @param month
    //      *            the month.
    //      * @param day
    //      *            the day of the month.
    //      * @param hour
    //      *            the hour.
    //      * @param minute
    //      *            the minute.
    //      */
    //     constructor(
    //         [in] Int32 year,
    //         [in] Int32 month,
    //         [in] Int32 day,
    //         [in] Int32 hour,
    //         [in] Int32 minute);

    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to the specified date and
    //      * time in the default {@code TimeZone} and {@code Locale}.
    //      *
    //      * @param year
    //      *            the year.
    //      * @param month
    //      *            the month.
    //      * @param day
    //      *            the day of the month.
    //      * @param hour
    //      *            the hour.
    //      * @param minute
    //      *            the minute.
    //      * @param second
    //      *            the second.
    //      */
    //     constructor(
    //         [in] Int32 year,
    //         [in] Int32 month,
    //         [in] Int32 day,
    //         [in] Int32 hour,
    //         [in] Int32 minute,
    //         [in] Int32 second);

    //     constructor(
    //         [in] Int64 milliseconds);

    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to the current date and
    //      * time and using the specified {@code Locale} and the default {@code TimeZone}.
    //      *
    //      * @param locale
    //      *            the {@code Locale}.
    //      */
    //     constructor(
    //         [in] ILocale* locale);

    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to the current date and
    //      * time and using the specified {@code TimeZone} and the default {@code Locale}.
    //      *
    //      * @param timezone
    //      *            the {@code TimeZone}.
    //      */
    //     constructor(
    //         [in] ITimeZone* timeZone);

    //     /**
    //      * Constructs a new {@code GregorianCalendar} initialized to the current date and
    //      * time and using the specified {@code TimeZone} and {@code Locale}.
    //      *
    //      * @param timezone
    //      *            the {@code TimeZone}.
    //      * @param locale
    //      *            the {@code Locale}.
    //      */
    //     constructor(
    //         [in] ITimeZone* timeZone,
    //         [in] ILocale* locale);

    //     constructor(
    //         [in] Boolean ignored);

    //     interface IGregorianCalendar;
    //     interface ISerializable;
    //     interface ICloneable;
    //     interface IComparable;
    // }

    // singleton class CCalendarHelper {
    //     interface ICalendarHelper;
    // }

    // singleton class CTimeZoneHelper {
    //     interface ITimeZoneHelper;
    // }

    // class CSimpleTimeZone {
    //     /**
    //      * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT
    //      * and time zone ID. Timezone IDs can be obtained from
    //      * {@code TimeZone.getAvailableIDs}. Normally you should use {@code TimeZone.getDefault} to
    //      * construct a {@code TimeZone}.
    //      *
    //      * @param offset
    //      *            the given base time zone offset to GMT.
    //      * @param name
    //      *            the time zone ID which is obtained from
    //      *            {@code TimeZone.getAvailableIDs}.
    //      */
    //     constructor(
    //         [in] Int32 offset,
    //         [in] String name);

    //     /**
    //      * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT,
    //      * time zone ID, and times to start and end the daylight savings time. Timezone IDs can
    //      * be obtained from {@code TimeZone.getAvailableIDs}. Normally you should use
    //      * {@code TimeZone.getDefault} to create a {@code TimeZone}. For a time zone that does not
    //      * use daylight saving time, do not use this constructor; instead you should
    //      * use {@code SimpleTimeZone(rawOffset, ID)}.
    //      * <p>
    //      * By default, this constructor specifies day-of-week-in-month rules. That
    //      * is, if the {@code startDay} is 1, and the {@code startDayOfWeek} is {@code SUNDAY}, then this
    //      * indicates the first Sunday in the {@code startMonth}. A {@code startDay} of -1 likewise
    //      * indicates the last Sunday. However, by using negative or zero values for
    //      * certain parameters, other types of rules can be specified.
    //      * <p>
    //      * Day of month: To specify an exact day of the month, such as March 1, set
    //      * {@code startDayOfWeek} to zero.
    //      * <p>
    //      * Day of week after day of month: To specify the first day of the week
    //      * occurring on or after an exact day of the month, make the day of the week
    //      * negative. For example, if {@code startDay} is 5 and {@code startDayOfWeek} is {@code -MONDAY},
    //      * this indicates the first Monday on or after the 5th day of the
    //      * {@code startMonth}.
    //      * <p>
    //      * Day of week before day of month: To specify the last day of the week
    //      * occurring on or before an exact day of the month, make the day of the
    //      * week and the day of the month negative. For example, if {@code startDay} is {@code -21}
    //      * and {@code startDayOfWeek} is {@code -WEDNESDAY}, this indicates the last Wednesday on or
    //      * before the 21st of the {@code startMonth}.
    //      * <p>
    //      * The above examples refer to the {@code startMonth}, {@code startDay}, and {@code startDayOfWeek};
    //      * the same applies for the {@code endMonth}, {@code endDay}, and {@code endDayOfWeek}.
    //      * <p>
    //      * The daylight savings time difference is set to the default value: one hour.
    //      *
    //      * @param offset
    //      *            the given base time zone offset to GMT.
    //      * @param name
    //      *            the time zone ID which is obtained from
    //      *            {@code TimeZone.getAvailableIDs}.
    //      * @param startMonth
    //      *            the daylight savings starting month. The month indexing is 0-based. eg, 0
    //      *            for January.
    //      * @param startDay
    //      *            the daylight savings starting day-of-week-in-month. Please see
    //      *            the member description for an example.
    //      * @param startDayOfWeek
    //      *            the daylight savings starting day-of-week. Please see the
    //      *            member description for an example.
    //      * @param startTime
    //      *            the daylight savings starting time in local wall time, which
    //      *            is standard time in this case. Please see the member
    //      *            description for an example.
    //      * @param endMonth
    //      *            the daylight savings ending month. The month indexing is 0-based. eg, 0 for
    //      *            January.
    //      * @param endDay
    //      *            the daylight savings ending day-of-week-in-month. Please see
    //      *            the member description for an example.
    //      * @param endDayOfWeek
    //      *            the daylight savings ending day-of-week. Please see the member
    //      *            description for an example.
    //      * @param endTime
    //      *            the daylight savings ending time in local wall time, which is
    //      *            daylight time in this case. Please see the member description
    //      *            for an example.
    //      * @throws IllegalArgumentException
    //      *             if the month, day, dayOfWeek, or time parameters are out of
    //      *             range for the start or end rule.
    //      */
    //     constructor(
    //         [in] Int32 offset,
    //         [in] String name,
    //         [in] Int32 startMonth,
    //         [in] Int32 startDay,
    //         [in] Int32 startDayOfWeek,
    //         [in] Int32 startTime,
    //         [in] Int32 endMonth,
    //         [in] Int32 endDay,
    //         [in] Int32 endDayOfWeek,
    //         [in] Int32 endTime);

    //     /**
    //      * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT,
    //      * time zone ID, times to start and end the daylight savings time, and
    //      * the daylight savings time difference in milliseconds.
    //      *
    //      * @param offset
    //      *            the given base time zone offset to GMT.
    //      * @param name
    //      *            the time zone ID which is obtained from
    //      *            {@code TimeZone.getAvailableIDs}.
    //      * @param startMonth
    //      *            the daylight savings starting month. Month is 0-based. eg, 0
    //      *            for January.
    //      * @param startDay
    //      *            the daylight savings starting day-of-week-in-month. Please see
    //      *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param startDayOfWeek
    //      *            the daylight savings starting day-of-week. Please see the
    //      *            description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param startTime
    //      *            The daylight savings starting time in local wall time, which
    //      *            is standard time in this case. Please see the description of
    //      *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param endMonth
    //      *            the daylight savings ending month. Month is 0-based. eg, 0 for
    //      *            January.
    //      * @param endDay
    //      *            the daylight savings ending day-of-week-in-month. Please see
    //      *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param endDayOfWeek
    //      *            the daylight savings ending day-of-week. Please see the description of
    //      *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param endTime
    //      *            the daylight savings ending time in local wall time, which is
    //      *            daylight time in this case. Please see the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)}
    //      *            for an example.
    //      * @param daylightSavings
    //      *            the daylight savings time difference in milliseconds.
    //      * @throws IllegalArgumentException
    //      *                if the month, day, dayOfWeek, or time parameters are out of
    //      *                range for the start or end rule.
    //      */
    //     constructor(
    //         [in] Int32 offset,
    //         [in] String name,
    //         [in] Int32 startMonth,
    //         [in] Int32 startDay,
    //         [in] Int32 startDayOfWeek,
    //         [in] Int32 startTime,
    //         [in] Int32 endMonth,
    //         [in] Int32 endDay,
    //         [in] Int32 endDayOfWeek,
    //         [in] Int32 endTime,
    //         [in] Int32 daylightSavings);

    //     /**
    //      * Construct a {@code SimpleTimeZone} with the given base time zone offset from GMT,
    //      * time zone ID, times to start and end the daylight savings time including a
    //      * mode specifier, the daylight savings time difference in milliseconds.
    //      * The mode specifies either {@link #WALL_TIME}, {@link #STANDARD_TIME}, or
    //      * {@link #UTC_TIME}.
    //      *
    //      * @param offset
    //      *            the given base time zone offset to GMT.
    //      * @param name
    //      *            the time zone ID which is obtained from
    //      *            {@code TimeZone.getAvailableIDs}.
    //      * @param startMonth
    //      *            the daylight savings starting month. The month indexing is 0-based. eg, 0
    //      *            for January.
    //      * @param startDay
    //      *            the daylight savings starting day-of-week-in-month. Please see
    //      *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param startDayOfWeek
    //      *            the daylight savings starting day-of-week. Please see the
    //      *            description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param startTime
    //      *            the time of day in milliseconds on which daylight savings
    //      *            time starts, based on the {@code startTimeMode}.
    //      * @param startTimeMode
    //      *            the mode (UTC, standard, or wall time) of the start time
    //      *            value.
    //      * @param endDay
    //      *            the day of the week on which daylight savings time ends.
    //      * @param endMonth
    //      *            the daylight savings ending month. The month indexing is 0-based. eg, 0 for
    //      *            January.
    //      * @param endDayOfWeek
    //      *            the daylight savings ending day-of-week. Please see the description of
    //      *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
    //      * @param endTime
    //      *            the time of day in milliseconds on which daylight savings
    //      *            time ends, based on the {@code endTimeMode}.
    //      * @param endTimeMode
    //      *            the mode (UTC, standard, or wall time) of the end time value.
    //      * @param daylightSavings
    //      *            the daylight savings time difference in milliseconds.
    //      * @throws IllegalArgumentException
    //      *             if the month, day, dayOfWeek, or time parameters are out of
    //      *             range for the start or end rule.
    //      */
    //     constructor(
    //         [in] Int32 offset,
    //         [in] String name,
    //         [in] Int32 startMonth,
    //         [in] Int32 startDay,
    //         [in] Int32 startDayOfWeek,
    //         [in] Int32 startTime,
    //         [in] Int32 startTimeMode,
    //         [in] Int32 endMonth,
    //         [in] Int32 endDay,
    //         [in] Int32 endDayOfWeek,
    //         [in] Int32 endTime,
    //         [in] Int32 endTimeMode,
    //         [in] Int32 daylightSavings);

    //     interface ISimpleTimeZone;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // [deprecated]
    // class CZoneInfo {
    //     constructor(
    //         [in] String name,
    //         [in] ArrayOf<Int32>* transitions,
    //         [in] ArrayOf<Byte>* type,
    //         [in] ArrayOf<Int32>* gmtoff,
    //         [in] ArrayOf<Byte>* isdst);

    //     interface IZoneInfo;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CTimer {
    //     constructor(
    //         [in] String name,
    //         [in] Boolean isDaemon);

    //     constructor(
    //         [in] String name);

    //     constructor(
    //         [in] Boolean isDaemon);

    //     constructor();

    //     interface ITimer;
    // }

    // class CProperties {
    //     constructor();

    //     constructor(
    //         [in] IProperties * properties);

    //     interface IProperties;
    //     interface IMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // singleton class CTimeZoneGetterHelper {
    //     interface ITimeZoneGetterHelper;
    // }

    // class CLinkedList {
    //     constructor();

    //     constructor(
    //         [in] ICollection* collection);

    //     interface ILinkedList;
    //     interface ICloneable;
    // }

    // class CArrayList {
    //     constructor();

    //     constructor(
    //         [in] Int32 capacity);

    //     constructor(
    //         [in] ICollection* collection);

    //     interface IArrayList;
    //     interface ICloneable;
    //     interface ISerializable;
    //     interface IRandomAccess;
    // }

    // class CArrayDeque {
    //     constructor();

    //     constructor(
    //         [in] Int32 numElements);

    //     constructor(
    //         [in] ICollection* c);

    //     interface IArrayDeque;
    //     interface IDeque;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CVector {
    //     constructor();

    //     constructor(
    //         [in] Int32 capacity);

    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Int32 capacityIncrement);

    //     constructor(
    //         [in] ICollection* collection);

    //     interface IVector;
    //     interface ICloneable;
    //     interface ISerializable;
    //     interface IRandomAccess;
    // }

    singleton class CCollections {
        interface ICollections;
    }

    class CFormatter {
        /**
         * Constructs a {@code Formatter}.
         *
         * <p>The output is written to a {@code StringBuilder} which can be acquired by invoking
         * {@link #out()} and whose content can be obtained by calling {@code toString}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         */
        constructor();

        /**
         * Constructs a {@code Formatter} whose output will be written to the
         * specified {@code Appendable}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param a
         *            the output destination of the {@code Formatter}. If {@code a} is {@code null},
         *            then a {@code StringBuilder} will be used.
         */
        constructor(
            [in] IAppendable* a);

        /**
         * Constructs a {@code Formatter} with the specified {@code Locale}.
         *
         * <p>The output is written to a {@code StringBuilder} which can be acquired by invoking
         * {@link #out()} and whose content can be obtained by calling {@code toString}.
         *
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         */
        constructor(
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} with the specified {@code Locale}
         * and whose output will be written to the
         * specified {@code Appendable}.
         *
         * @param a
         *            the output destination of the {@code Formatter}. If {@code a} is {@code null},
         *            then a {@code StringBuilder} will be used.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         */
        constructor(
            [in] IAppendable* a,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified file.
         *
         * <p>The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param fileName
         *            the filename of the file that is used as the output
         *            destination for the {@code Formatter}. The file will be truncated to
         *            zero size if the file exists, or else a new file will be
         *            created. The output of the {@code Formatter} is buffered.
         * @throws FileNotFoundException
         *             if the filename does not denote a normal and writable file,
         *             or if a new file cannot be created, or if any error arises when
         *             opening or creating the file.
         */
        constructor(
             [in] String fileName);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified file.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param fileName
         *            the filename of the file that is used as the output
         *            destination for the {@code Formatter}. The file will be truncated to
         *            zero size if the file exists, or else a new file will be
         *            created. The output of the {@code Formatter} is buffered.
         * @param csn
         *           the name of the charset for the {@code Formatter}.
         * @throws FileNotFoundException
         *            if the filename does not denote a normal and writable file,
         *            or if a new file cannot be created, or if any error arises when
         *            opening or creating the file.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] String fileName,
            [in] String csn);

        /**
         * Constructs a {@code Formatter} with the given {@code Locale} and charset,
         * and whose output is written to the specified file.
         *
         * @param fileName
         *            the filename of the file that is used as the output
         *            destination for the {@code Formatter}. The file will be truncated to
         *            zero size if the file exists, or else a new file will be
         *            created. The output of the {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         * @throws FileNotFoundException
         *             if the filename does not denote a normal and writable file,
         *             or if a new file cannot be created, or if any error arises when
         *             opening or creating the file.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] String fileName,
            [in] String csn,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified {@code File}.
         *
         * The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param file
         *            the {@code File} that is used as the output destination for the
         *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
         *            exists, or else a new {@code File} will be created. The output of the
         *            {@code Formatter} is buffered.
         * @throws FileNotFoundException
         *             if the {@code File} is not a normal and writable {@code File}, or if a
         *             new {@code File} cannot be created, or if any error rises when opening or
         *             creating the {@code File}.
         */
        constructor(
             [in] IFile* file);

        /**
         * Constructs a {@code Formatter} with the given charset,
         * and whose output is written to the specified {@code File}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param file
         *            the {@code File} that is used as the output destination for the
         *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
         *            exists, or else a new {@code File} will be created. The output of the
         *            {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @throws FileNotFoundException
         *             if the {@code File} is not a normal and writable {@code File}, or if a
         *             new {@code File} cannot be created, or if any error rises when opening or
         *             creating the {@code File}.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IFile* file,
            [in] String csn);

        /**
         * Constructs a {@code Formatter} with the given {@code Locale} and charset,
         * and whose output is written to the specified {@code File}.
         *
         * @param file
         *            the {@code File} that is used as the output destination for the
         *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
         *            exists, or else a new {@code File} will be created. The output of the
         *            {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         * @throws FileNotFoundException
         *             if the {@code File} is not a normal and writable {@code File}, or if a
         *             new {@code File} cannot be created, or if any error rises when opening or
         *             creating the {@code File}.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IFile* file,
            [in] String csn,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified {@code OutputStream}.
         *
         * <p>The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param os
         *            the stream to be used as the destination of the {@code Formatter}.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a {@code Formatter} with the given charset,
         * and whose output is written to the specified {@code OutputStream}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param os
         *            the stream to be used as the destination of the {@code Formatter}.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String csn);

        /**
         * Constructs a {@code Formatter} with the given {@code Locale} and charset,
         * and whose output is written to the specified {@code OutputStream}.
         *
         * @param os
         *            the stream to be used as the destination of the {@code Formatter}.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String csn,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified {@code PrintStream}.
         *
         * <p>The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param ps
         *            the {@code PrintStream} used as destination of the {@code Formatter}. If
         *            {@code ps} is {@code null}, then a {@code NullPointerException} will
         *            be raised.
         */
        constructor(
            [in] IPrintStream* ps);

        interface IFormatter;
        interface ICloseable;
        interface IFlushable;
     }

    // singleton class CCurrencyHelper {
    //     interface ICurrencyHelper;
    // }

    // class CHashMap {
    //     /**
    //      * Constructs a new empty {@code HashMap} instance.
    //      */
    //     // @SuppressWarnings("unchecked")
    //     constructor();

    //     /**
    //      * Constructs a new {@code HashMap} instance with the specified capacity.
    //      *
    //      * @param capacity
    //      *            the initial capacity of this hash map.
    //      * @throws IllegalArgumentException
    //      *                when the capacity is less than zero.
    //      */
    //     constructor(
    //         [in] Int32 capacity);

    //     /**
    //      * Constructs a new {@code HashMap} instance with the specified capacity and
    //      * load factor.
    //      *
    //      * @param capacity
    //      *            the initial capacity of this hash map.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      * @throws IllegalArgumentException
    //      *                when the capacity is less than zero or the load factor is
    //      *                less or equal to zero or NaN.
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Constructs a new {@code HashMap} instance containing the mappings from
    //      * the specified map.
    //      *
    //      * @param map
    //      *            the mappings to add.
    //      */
    //     constructor(
    //         [in] IMap* map);

    //     interface IMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CHashSet {
    //     /**
    //      * Constructs a new empty instance of {@code HashSet}.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new instance of {@code HashSet} with the specified capacity.
    //      *
    //      * @param capacity
    //      *            the initial capacity of this {@code HashSet}.
    //      */
    //     constructor(
    //         [in] Int32 capacity);

    //     /**
    //      * Constructs a new instance of {@code HashSet} with the specified capacity
    //      * and load factor.
    //      *
    //      * @param capacity
    //      *            the initial capacity.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Constructs a new instance of {@code HashSet} containing the unique
    //      * elements in the specified collection.
    //      *
    //      * @param collection
    //      *            the collection of elements to add.
    //      */
    //     constructor(
    //         [in] ICollection* collection);

    //     constructor(
    //         [in] IMap* backingMap);

    //     interface ISet;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CHashTable {
    //     /**
    //      * Constructs a new {@code Hashtable} using the default capacity and load
    //      * factor.
    //      */
    //     // @SuppressWarnings("unchecked")
    //     constructor();

    //     /**
    //      * Constructs a new {@code Hashtable} using the specified capacity and the
    //      * default load factor.
    //      *
    //      * @param capacity
    //      *            the initial capacity.
    //      */
    //     constructor(
    //         [in] Int32 capacity);

    //     /**
    //      * Constructs a new {@code Hashtable} using the specified capacity and load
    //      * factor.
    //      *
    //      * @param capacity
    //      *            the initial capacity.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Constructs a new instance of {@code Hashtable} containing the mappings
    //      * from the specified map.
    //      *
    //      * @param map
    //      *            the mappings to add.
    //      */
    //     constructor(
    //         [in] IMap* map);

    //     interface IDictionary;
    //     interface IMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CIdentityHashMap {
    //     /**
    //      * Creates an IdentityHashMap with default expected maximum size.
    //      */
    //     constructor();

    //     /**
    //      * Creates an IdentityHashMap with the specified maximum size parameter.
    //      *
    //      * @param maxSize
    //      *            The estimated maximum number of entries that will be put in
    //      *            this map.
    //      */
    //     constructor(
    //         [in] Int32 maxSize);

    //     /**
    //      * Creates an IdentityHashMap using the given map as initial values.
    //      *
    //      * @param map
    //      *            A map of (key,value) pairs to copy into the IdentityHashMap.
    //      */
    //     constructor(
    //         [in] IMap* map);

    //     interface IMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CTreeMap {
    //     /**
    //      * Create a natural order, empty tree map whose keys must be mutually
    //      * comparable and non-null.
    //      */
    //     // @SuppressWarnings("unchecked") // unsafe! this assumes K is comparable
    //     constructor();

    //     /**
    //      * Create a natural order tree map populated with the key/value pairs of
    //      * {@code copyFrom}. This map's keys must be mutually comparable and
    //      * non-null.
    //      *
    //      * <p>Even if {@code copyFrom} is a {@code SortedMap}, the constructed map
    //      * <strong>will not</strong> use {@code copyFrom}'s ordering. This
    //      * constructor always creates a naturally-ordered map. Because the {@code
    //      * TreeMap} constructor overloads are ambiguous, prefer to construct a map
    //      * and populate it in two steps: <pre>   {@code
    //      *   TreeMap<String, Integer> customOrderedMap
    //      *       = new TreeMap<String, Integer>(copyFrom.comparator());
    //      *   customOrderedMap.putAll(copyFrom);
    //      * }</pre>
    //      */
    //     constructor(
    //         [in] IMap* copyFrommap);

    //     /**
    //      * Create a tree map ordered by {@code comparator}. This map's keys may only
    //      * be null if {@code comparator} permits.
    //      *
    //      * @param comparator the comparator to order elements with, or {@code null} to use the natural
    //      * ordering.
    //      */
    //     // @SuppressWarnings("unchecked") // unsafe! if comparator is null, this assumes K is comparable
    //     constructor(
    //         [in] IComparator* comparator);

    //     /**
    //      * Create a tree map with the ordering and key/value pairs of {@code
    //      * copyFrom}. This map's keys may only be null if the {@code copyFrom}'s
    //      * ordering permits.
    //      *
    //      * <p>The constructed map <strong>will always use</strong> {@code
    //      * copyFrom}'s ordering. Because the {@code TreeMap} constructor overloads
    //      * are ambiguous, prefer to construct a map and populate it in two steps:
    //      * <pre>   {@code
    //      *   TreeMap<String, Integer> customOrderedMap
    //      *       = new TreeMap<String, Integer>(copyFrom.comparator());
    //      *   customOrderedMap.putAll(copyFrom);
    //      * }</pre>
    //      */
    //     // @SuppressWarnings("unchecked") // if copyFrom's keys are comparable this map's keys must be also
    //     constructor(
    //         [in] ISortedMap* copyFrom);

    //     interface INavigableMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CTreeSet {
    //     /**
    //      * Constructs a new empty instance of {@code TreeSet} which uses natural
    //      * ordering.
    //      */
    //     constructor();

    //     constructor(
    //         [in] INavigableMap* navmap);

    //     /**
    //      * Constructs a new instance of {@code TreeSet} which uses natural ordering
    //      * and containing the unique elements in the specified collection.
    //      *
    //      * @param collection
    //      *            the collection of elements to add.
    //      * @throws ClassCastException
    //      *                when an element in the collection does not implement the
    //      *                Comparable interface, or the elements in the collection
    //      *                cannot be compared.
    //      */
    //     constructor(
    //         [in] ICollection* map);

    //     /**
    //      * Constructs a new empty instance of {@code TreeSet} which uses the
    //      * specified comparator.
    //      *
    //      * @param comparator
    //      *            the comparator to use.
    //      */
    //     constructor(
    //         [in] IComparator* comparator);

    //     /**
    //      * Constructs a new instance of {@code TreeSet} containing the elements of
    //      * the specified SortedSet and using the same Comparator.
    //      *
    //      * @param set
    //      *            the SortedSet of elements to add.
    //      */
    //     constructor(
    //         [in] ISortedSet* set);

    //     interface INavigableSet;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CWeakHashMap {
    //     /**
    //      * Constructs a new empty {@code WeakHashMap} instance.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new empty {@code WeakHashMap} instance.
    //      */
    //     constructor(
    //         [in] Int32 capacity);

    //     /**
    //      * Constructs a new {@code WeakHashMap} instance with the specified capacity
    //      * and load factor.
    //      *
    //      * @param capacity
    //      *            the initial capacity of this map.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      * @throws IllegalArgumentException
    //      *             if the capacity is less than zero or the load factor is less
    //      *             or equal to zero.
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Constructs a new {@code WeakHashMap} instance containing the mappings
    //      * from the specified map.
    //      *
    //      * @param map
    //      *            the mappings to add.
    //      */
    //     constructor(
    //         [in] IMap* map);

    //     interface IMap;
    // }

    // class CLinkedHashMap {
    //     /**
    //      * Constructs a new empty {@code LinkedHashMap} instance.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new {@code LinkedHashMap} instance with the specified
    //      * capacity.
    //      *
    //      * @param initialCapacity
    //      *            the initial capacity of this map.
    //      * @exception IllegalArgumentException
    //      *                when the capacity is less than zero.
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity);

    //     /**
    //      * Constructs a new {@code LinkedHashMap} instance with the specified
    //      * capacity and load factor.
    //      *
    //      * @param initialCapacity
    //      *            the initial capacity of this map.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      * @throws IllegalArgumentException
    //      *             when the capacity is less than zero or the load factor is
    //      *             less or equal to zero.
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Constructs a new {@code LinkedHashMap} instance with the specified
    //      * capacity, load factor and a flag specifying the ordering behavior.
    //      *
    //      * @param initialCapacity
    //      *            the initial capacity of this hash map.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      * @param accessOrder
    //      *            {@code true} if the ordering should be done based on the last
    //      *            access (from least-recently accessed to most-recently
    //      *            accessed), and {@code false} if the ordering should be the
    //      *            order in which the entries were inserted.
    //      * @throws IllegalArgumentException
    //      *             when the capacity is less than zero or the load factor is
    //      *             less or equal to zero.
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity,
    //         [in] Float loadFactor,
    //         [in] Boolean accessOrder);

    //     /**
    //      * Constructs a new {@code LinkedHashMap} instance containing the mappings
    //      * from the specified map. The order of the elements is preserved.
    //      *
    //      * @param map
    //      *            the mappings to add.
    //      */
    //     constructor(
    //         [in] IMap* map);

    //     interface IMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CLinkedHashSet {
    //     /**
    //      * Constructs a new empty instance of {@code LinkedHashSet}.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a new instance of {@code LinkedHashSet} with the specified
    //      * capacity.
    //      *
    //      * @param capacity
    //      *            the initial capacity of this {@code LinkedHashSet}.
    //      */
    //     constructor(
    //         [in] Int32 capacity);

    //     /**
    //      * Constructs a new instance of {@code LinkedHashSet} with the specified
    //      * capacity and load factor.
    //      *
    //      * @param capacity
    //      *            the initial capacity.
    //      * @param loadFactor
    //      *            the initial load factor.
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Constructs a new instance of {@code LinkedHashSet} containing the unique
    //      * elements in the specified collection.
    //      *
    //      * @param collection
    //      *            the collection of elements to add.
    //      */
    //     constructor(
    //         [in] ICollection* collection);

    //     interface ISet;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // class CEnumMap {
    //     constructor();

    //     /**
    //      * Constructs an empty {@code EnumMap} using the given key type.
    //      *
    //      * @param keyType
    //      *            the class object giving the type of the keys used by this {@code EnumMap}.
    //      * @throws NullPointerException
    //      *             if {@code keyType} is {@code null}.
    //      */
    //     constructor(
    //         [in] InterfaceID keyType);

    //     /**
    //      * Constructs an {@code EnumMap} using the same key type as the given {@code EnumMap} and
    //      * initially containing the same mappings.
    //      *
    //      * @param map
    //      *            the {@code EnumMap} from which this {@code EnumMap} is initialized.
    //      * @throws NullPointerException
    //      *             if {@code map} is {@code null}.
    //      */
    //     constructor(
    //         [in] IEnumMap* enummap);

    //     /**
    //      * Constructs an {@code EnumMap} initialized from the given map. If the given map
    //      * is an {@code EnumMap} instance, this constructor behaves in the exactly the same
    //      * way as {@link EnumMap#EnumMap(EnumMap)}}. Otherwise, the given map
    //      * should contain at least one mapping.
    //      *
    //      * @param map
    //      *            the map from which this {@code EnumMap} is initialized.
    //      * @throws IllegalArgumentException
    //      *             if {@code map} is not an {@code EnumMap} instance and does not contain
    //      *             any mappings.
    //      * @throws NullPointerException
    //      *             if {@code map} is {@code null}.
    //      */
    //     // @SuppressWarnings("unchecked")
    //     constructor(
    //         [in] IMap* map);

    //     interface IEnumMap;
    //     interface ICloneable;
    //     interface ISerializable;
    // }

    // singleton class CDualPivotQuicksortHelper {
    //     interface IDualPivotQuicksortHelper;
    // }

    // class CStack {
    //     /**
    //      * Constructs a stack with the default size of {@code Vector}.
    //      */
    //     constructor();

    //     interface IStack;
    // }

    // class CStringTokenizer {
    //     /**
    //      * Constructs a new {@code StringTokenizer} for the parameter string using
    //      * whitespace as the delimiter. The {@code returnDelimiters} flag is set to
    //      * {@code false}.
    //      *
    //      * @param string
    //      *            the string to be tokenized.
    //      */
    //     constructor(
    //         [in] String string);

    //     /**
    //      * Constructs a new {@code StringTokenizer} for the parameter string using
    //      * the specified delimiters. The {@code returnDelimiters} flag is set to
    //      * {@code false}. If {@code delimiters} is {@code null}, this constructor
    //      * doesn't throw an {@code Exception}, but later calls to some methods might
    //      * throw a {@code NullPointerException}.
    //      *
    //      * @param string
    //      *            the string to be tokenized.
    //      * @param delimiters
    //      *            the delimiters to use.
    //      */
    //     constructor(
    //         [in] String string,
    //         [in] String delimiters);

    //     /**
    //      * Constructs a new {@code StringTokenizer} for the parameter string using
    //      * the specified delimiters, returning the delimiters as tokens if the
    //      * parameter {@code returnDelimiters} is {@code true}. If {@code delimiters}
    //      * is null this constructor doesn't throw an {@code Exception}, but later
    //      * calls to some methods might throw a {@code NullPointerException}.
    //      *
    //      * @param string
    //      *            the string to be tokenized.
    //      * @param delimiters
    //      *            the delimiters to use.
    //      * @param returnDelimiters
    //      *            {@code true} to return each delimiter as a token.
    //      */
    //     constructor(
    //         [in] String string,
    //         [in] String delimiters,
    //         [in] Boolean returnDelimiters);

    //     interface IStringTokenizer;
    // }

    // class CScanner {
    //     /**
    //      * Creates a {@code Scanner} with the specified {@code File} as input. The default charset
    //      * is applied when reading the file.
    //      *
    //      * @param src
    //      *            the file to be scanned.
    //      * @throws FileNotFoundException
    //      *             if the specified file does not exist.
    //      */
    //     constructor(
    //         [in] IFile* filesrc);

    //     /**
    //      * Creates a {@code Scanner} with the specified {@code File} as input. The specified charset
    //      * is applied when reading the file.
    //      *
    //      * @param src
    //      *            the file to be scanned.
    //      * @param charsetName
    //      *            the name of the encoding type of the file.
    //      * @throws FileNotFoundException
    //      *             if the specified file does not exist.
    //      * @throws IllegalArgumentException
    //      *             if the specified coding does not exist.
    //      */
    //     constructor(
    //         [in] IFile* filesrc,
    //         [in] String charsetName);

    //     /**
    //      * Creates a {@code Scanner} on the specified string.
    //      *
    //      * @param src
    //      *            the string to be scanned.
    //      */
    //     constructor(
    //         [in] String strsrc);

    //     /**
    //      * Creates a {@code Scanner} on the specified {@code InputStream}. The default charset is
    //      * applied when decoding the input.
    //      *
    //      * @param src
    //      *            the {@code InputStream} to be scanned.
    //      */
    //     constructor(
    //         [in] IInputStream* inputsrc);

    //     /**
    //      * Creates a {@code Scanner} on the specified {@code InputStream}. The specified charset is
    //      * applied when decoding the input.
    //      *
    //      * @param src
    //      *            the {@code InputStream} to be scanned.
    //      * @param charsetName
    //      *            the encoding type of the {@code InputStream}.
    //      * @throws IllegalArgumentException
    //      *             if the specified character set is not found.
    //      */
    //     constructor(
    //         [in] IInputStream* inputsrc,
    //         [in] String charsetName);

    //     /**
    //      * Creates a {@code Scanner} with the specified {@code Readable} as input.
    //      *
    //      * @param src
    //      *            the {@code Readable} to be scanned.
    //      */
    //     constructor(
    //         [in] IReadable* readsrc);

    //     /**
    //      * Creates a {@code Scanner} with the specified {@code ReadableByteChannel} as
    //      * input. The default charset is applied when decoding the input.
    //      *
    //      * @param src
    //      *            the {@code ReadableByteChannel} to be scanned.
    //      */
    //     constructor(
    //         [in] IReadableByteChannel* rbcsrc);

    //     /**
    //      * Creates a {@code Scanner} with the specified {@code ReadableByteChannel} as
    //      * input. The specified charset is applied when decoding the input.
    //      *
    //      * @param src
    //      *            the {@code ReadableByteChannel} to be scanned.
    //      * @param charsetName
    //      *            the encoding type of the content.
    //      * @throws IllegalArgumentException
    //      *             if the specified character set is not found.
    //      */
    //     constructor(
    //         [in] IReadableByteChannel* rbcsrc,
    //         [in] String charsetName);

    //     interface IScanner;
    // }

    // class CPropertyResourceBundle {
    //     constructor();

    //     /**
    //      * Constructs a new instance of {@code PropertyResourceBundle} and loads the
    //      * properties file from the specified {@code InputStream}.
    //      *
    //      * @param stream
    //      *            the {@code InputStream}.
    //      * @throws IOException
    //      *             if an error occurs during a read operation on the
    //      *             {@code InputStream}.
    //      */
    //     constructor(
    //         [in] IInputStream* stream);

    //     /**
    //      * Constructs a new resource bundle with properties read from {@code reader}.
    //      *
    //      * @param reader the {@code Reader}
    //      * @throws IOException
    //      * @since 1.6
    //      */
    //     constructor(
    //         [in] IReader* reader);

    //     interface IPropertyResourceBundle;
    // }

    // class CPriorityQueue {
    //     /**
    //      * Constructs a priority queue with an initial capacity of 11 and natural
    //      * ordering.
    //      */
    //     constructor();

    //     /**
    //      * Constructs a priority queue with the specified capacity and natural
    //      * ordering.
    //      *
    //      * @param initialCapacity
    //      *            the specified capacity.
    //      * @throws IllegalArgumentException
    //      *             if the initialCapacity is less than 1.
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity);

    //     /**
    //      * Constructs a priority queue with the specified capacity and comparator.
    //      *
    //      * @param initialCapacity
    //      *            the specified capacity.
    //      * @param comparator
    //      *            the specified comparator. If it is null, the natural ordering
    //      *            will be used.
    //      * @throws IllegalArgumentException
    //      *             if the initialCapacity is less than 1.
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity,
    //         [in] IComparator* comparator);

    //     /**
    //      * Constructs a priority queue that contains the elements of a collection.
    //      * The constructed priority queue has the initial capacity of 110% of the
    //      * size of the collection. The queue uses natural ordering to order its
    //      * elements.
    //      *
    //      * @param c
    //      *            the collection whose elements will be added to the priority
    //      *            queue to be constructed.
    //      * @throws ClassCastException
    //      *             if any of the elements in the collection are not comparable.
    //      * @throws NullPointerException
    //      *             if any of the elements in the collection are null.
    //      */
    //     constructor(
    //         [in] ICollection* c);

    //     /**
    //      * Constructs a priority queue that contains the elements of another
    //      * priority queue. The constructed priority queue has the initial capacity
    //      * of 110% of the specified one. Both priority queues have the same
    //      * comparator.
    //      *
    //      * @param c
    //      *            the priority queue whose elements will be added to the
    //      *            priority queue to be constructed.
    //      */
    //     constructor(
    //         [in] IPriorityQueue* pc);

    //     /**
    //      * Constructs a priority queue that contains the elements of a sorted set.
    //      * The constructed priority queue has the initial capacity of 110% of the
    //      * size of the sorted set. The priority queue will have the same comparator
    //      * as the sorted set.
    //      *
    //      * @param c
    //      *            the sorted set whose elements will be added to the priority
    //      *            queue to be constructed.
    //      */
    //     constructor(
    //         [in] ISortedSet* sc);

    //     interface IPriorityQueue;
    // }

    // class CObservable {
    //     /**
    //      * Constructs a new {@code Observable} object.
    //      */
    //     constructor();

    //     interface IObservable;
    // }

    } // namespace Utility
    } // namespace Elastos

    namespace Elastos {
    namespace Utility {
    namespace Regex {

    /**
     * The result of applying a {@code Pattern} to a given input. See {@link Pattern} for
     * example uses.
     */
    class CMatcher {
        /**
         * Creates a matcher for a given combination of pattern and input. Both
         * elements can be changed later on.
         *
         * @param pattern
         *            the pattern to use.
         * @param input
         *            the input to use.
         */
        constructor(
            [in] IPattern* pattern,
            [in] Elastos.Core.ICharSequence* inputSeq);

        interface IMatcher;
    }

    singleton class CMatcherHelper {
        interface IMatcherHelper;
    }

    singleton class CSplitter {
        interface ISplitter;
    }

    singleton class CPatternHelper {
        interface IPatternHelper;
    }

    } // namespace Regex
    } // namesapce Utility
    } // namespace Elastos

}
